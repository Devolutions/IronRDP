// <auto-generated/> by Diplomat

#pragma warning disable 0105
using System;
using System.Runtime.InteropServices;

using Devolutions.IronRdp.Diplomat;
#pragma warning restore 0105

namespace Devolutions.IronRdp;

#nullable enable

public partial class CredsspSequence: IDisposable
{
    private unsafe Raw.CredsspSequence* _inner;

    /// <summary>
    /// Creates a managed <c>CredsspSequence</c> from a raw handle.
    /// </summary>
    /// <remarks>
    /// Safety: you should not build two managed objects using the same raw handle (may causes use-after-free and double-free).
    /// <br/>
    /// This constructor assumes the raw struct is allocated on Rust side.
    /// If implemented, the custom Drop implementation on Rust side WILL run on destruction.
    /// </remarks>
    public unsafe CredsspSequence(Raw.CredsspSequence* handle)
    {
        _inner = handle;
    }

    /// <returns>
    /// A <c>PduHint</c> allocated on Rust side.
    /// </returns>
    public PduHint? NextPduHint()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("CredsspSequence");
            }
            Raw.PduHint* retVal = Raw.CredsspSequence.NextPduHint(_inner);
            if (retVal == null)
            {
                return null;
            }
            return new PduHint(retVal);
        }
    }

    /// <exception cref="IronRdpException"></exception>
    /// <returns>
    /// A <c>CredsspSequenceInitResult</c> allocated on Rust side.
    /// </returns>
    public static CredsspSequenceInitResult Init(ClientConnector connector, string serverName, byte[] serverPublicKey, KerberosConfig? kerberoConfigs)
    {
        unsafe
        {
            byte[] serverNameBuf = DiplomatUtils.StringToUtf8(serverName);
            nuint serverPublicKeyLength = (nuint)serverPublicKey.Length;
            nuint serverNameBufLength = (nuint)serverNameBuf.Length;
            Raw.ClientConnector* connectorRaw;
            connectorRaw = connector.AsFFI();
            if (connectorRaw == null)
            {
                throw new ObjectDisposedException("ClientConnector");
            }
            Raw.KerberosConfig* kerberoConfigsRaw;
            if (kerberoConfigs == null)
            {
                kerberoConfigsRaw = null;
            }
            else
            {
                kerberoConfigsRaw = kerberoConfigs.AsFFI();
                if (kerberoConfigsRaw == null)
                {
                    throw new ObjectDisposedException("KerberosConfig");
                }
            }
            fixed (byte* serverPublicKeyPtr = serverPublicKey)
            {
                fixed (byte* serverNameBufPtr = serverNameBuf)
                {
                    Raw.CredsspFfiResultBoxCredsspSequenceInitResultBoxIronRdpError result = Raw.CredsspSequence.Init(connectorRaw, serverNameBufPtr, serverNameBufLength, serverPublicKeyPtr, serverPublicKeyLength, kerberoConfigsRaw);
                    if (!result.isOk)
                    {
                        throw new IronRdpException(new IronRdpError(result.Err));
                    }
                    Raw.CredsspSequenceInitResult* retVal = result.Ok;
                    return new CredsspSequenceInitResult(retVal);
                }
            }
        }
    }

    /// <exception cref="IronRdpException"></exception>
    /// <returns>
    /// A <c>TsRequest</c> allocated on Rust side.
    /// </returns>
    public TsRequest DecodeServerMessage(byte[] pdu)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("CredsspSequence");
            }
            nuint pduLength = (nuint)pdu.Length;
            fixed (byte* pduPtr = pdu)
            {
                Raw.CredsspFfiResultOptBoxTsRequestBoxIronRdpError result = Raw.CredsspSequence.DecodeServerMessage(_inner, pduPtr, pduLength);
                if (!result.isOk)
                {
                    throw new IronRdpException(new IronRdpError(result.Err));
                }
                Raw.TsRequest* retVal = result.Ok;
                if (retVal == null)
                {
                    return null;
                }
                return new TsRequest(retVal);
            }
        }
    }

    /// <exception cref="IronRdpException"></exception>
    /// <returns>
    /// A <c>CredsspProcessGenerator</c> allocated on Rust side.
    /// </returns>
    public CredsspProcessGenerator ProcessTsRequest(TsRequest tsRequest)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("CredsspSequence");
            }
            Raw.TsRequest* tsRequestRaw;
            tsRequestRaw = tsRequest.AsFFI();
            if (tsRequestRaw == null)
            {
                throw new ObjectDisposedException("TsRequest");
            }
            Raw.CredsspFfiResultBoxCredsspProcessGeneratorBoxIronRdpError result = Raw.CredsspSequence.ProcessTsRequest(_inner, tsRequestRaw);
            if (!result.isOk)
            {
                throw new IronRdpException(new IronRdpError(result.Err));
            }
            Raw.CredsspProcessGenerator* retVal = result.Ok;
            return new CredsspProcessGenerator(retVal);
        }
    }

    /// <exception cref="IronRdpException"></exception>
    /// <returns>
    /// A <c>Written</c> allocated on Rust side.
    /// </returns>
    public Written HandleProcessResult(ClientState clientState, WriteBuf buf)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("CredsspSequence");
            }
            Raw.ClientState* clientStateRaw;
            clientStateRaw = clientState.AsFFI();
            if (clientStateRaw == null)
            {
                throw new ObjectDisposedException("ClientState");
            }
            Raw.WriteBuf* bufRaw;
            bufRaw = buf.AsFFI();
            if (bufRaw == null)
            {
                throw new ObjectDisposedException("WriteBuf");
            }
            Raw.CredsspFfiResultBoxWrittenBoxIronRdpError result = Raw.CredsspSequence.HandleProcessResult(_inner, clientStateRaw, bufRaw);
            if (!result.isOk)
            {
                throw new IronRdpException(new IronRdpError(result.Err));
            }
            Raw.Written* retVal = result.Ok;
            return new Written(retVal);
        }
    }

    /// <summary>
    /// Returns the underlying raw handle.
    /// </summary>
    public unsafe Raw.CredsspSequence* AsFFI()
    {
        return _inner;
    }

    /// <summary>
    /// Destroys the underlying object immediately.
    /// </summary>
    public void Dispose()
    {
        unsafe
        {
            if (_inner == null)
            {
                return;
            }

            Raw.CredsspSequence.Destroy(_inner);
            _inner = null;

            GC.SuppressFinalize(this);
        }
    }

    ~CredsspSequence()
    {
        Dispose();
    }
}
