mod clipboard_data_ref;
mod clipboard_impl;
mod cliprdr_backend;
mod os_clipboard;
mod remote_format_registry;
mod utils;

use std::sync::mpsc as mpsc_sync;

use ironrdp_cliprdr::backend::{ClipboardMessageProxy, CliprdrBackend, CliprdrBackendFactory};
use ironrdp_cliprdr::pdu::{
    ClipboardFormat, ClipboardFormatId, ClipboardGeneralCapabilityFlags, FormatDataRequest, FormatDataResponse,
};
use thiserror::Error;
use tracing::error;
use windows::Win32::Foundation::{FALSE, HWND};
use windows::Win32::System::DataExchange::{AddClipboardFormatListener, RemoveClipboardFormatListener};
use windows::Win32::UI::Shell::{RemoveWindowSubclass, SetWindowSubclass};
use windows::Win32::UI::WindowsAndMessaging::WM_USER;

use self::clipboard_impl::{clipboard_subproc, WinClipboardImpl};
use self::cliprdr_backend::WinCliprdrBackend;

const BACKEND_CHANNEL_SIZE: usize = 8;
const WM_CLIPRDR_BACKEND_EVENT: u32 = WM_USER;

pub type WinCliprdrResult<T> = Result<T, WinCliprdrError>;

#[derive(Debug, Error)]
pub enum WinCliprdrError {
    #[error("Failed to register clipboard format listener")]
    AddClipboardFormatListener,

    #[error("Failed to enumerate formats available in the current clipboard")]
    FormatsEnumeration,

    #[error("Clipboard is busy")]
    ClipboardAccessDenied,

    #[error("Failed to open the clipboard")]
    ClipboardOpen,

    #[error("Failed to empty the clipboard")]
    ClipboardEmpty,

    #[error("Failed to convert UTF-16 string to UTF-8")]
    Uft16Conversion,

    #[error("Failed to get current clipboard data")]
    ClipboardData,

    #[error("Failed to set clipboard data")]
    SetClipboardData,

    #[error("Failed to subclass window")]
    WindowSubclass,

    #[error("Failed to allocate global memory")]
    Alloc,

    #[error("Failed to receive data from remote clipboard")]
    DataReceiveTimeout,

    #[error("Failed to render clipboard format")]
    RenderFormat,

    #[error("WinAPI error")]
    WinAPI(#[from] windows::core::Error),
}

/// Sent from the clipboard backend shim to the actual WinAPI subproc event loop
#[derive(Debug)]
pub(crate) enum BackendEvent {
    // Events generated by OS event loop
    ClipboardUpdated,
    RenderFormat(ClipboardFormatId),
    RenderAllFormats,

    // PDU processing events
    DowngradedCapabilities(ClipboardGeneralCapabilityFlags),
    RemoteFormatList(Vec<ClipboardFormat>),
    FormatDataRequest(FormatDataRequest),
    FormatDataResponse(FormatDataResponse<'static>),
    RemoteRequestsFormatList,
}

/// Windows RDP client clipboard implementation.
///
/// IronRDP client implementation should provide raw window handle and message proxy to send
/// messages from the backend to `CLIPRDR` SVC.
///
/// [`WinClipboard`] instance holds ownership of the actual clipboard backend processing logic
/// and should be kept alive during the whole lifetime of the application.
///
/// This type is not thread safe, it should be used only in the main thread with a windows event
/// loop. (GUI thread). However, backend factory returned by [`WinClipboard::backend_factory`]
/// can be safely used in other threads.
pub struct WinClipboard {
    window: HWND,
    backend_tx: mpsc_sync::SyncSender<BackendEvent>,

    /// From MS docs:
    /// ```text
    /// You cannot use the subclassing helper functions to subclass a window across threads
    /// ```
    ///
    /// Therefore this type should be non-Send and non-Sync to prevent incorrect use.
    _thread_marker: std::marker::PhantomData<*const ()>,
}

impl WinClipboard {
    /// Creates new clipboard instance.
    ///
    /// # Safety
    ///
    /// `window` must be a valid window handle to safely initialize clipboard processing.
    /// The handle should be alive during the whole lifetime of the constructed clipboard instance.
    pub unsafe fn new(window: HWND, message_proxy: impl ClipboardMessageProxy + 'static) -> WinCliprdrResult<Self> {
        // Init clipboard processing for WinAPI event loop
        //
        // SAFETY: `window` is a valid window handle
        if unsafe { AddClipboardFormatListener(window) } == FALSE {
            return Err(WinCliprdrError::AddClipboardFormatListener);
        };

        let (backend_tx, backend_rx) = mpsc_sync::sync_channel(BACKEND_CHANNEL_SIZE);

        let ctx = Box::new(WinClipboardImpl::new(window, message_proxy, backend_rx));

        // We need to receive winapi messages in the main thread, so we need to add a subclass to
        // the window.

        // SAFETY: `window` is a valid window handle, `clipboard_subproc` is in the static memory,
        // `ctx` is valid and its ownership is transferred to the subclass via `into_raw`.
        let winapi_result =
            unsafe { SetWindowSubclass(window, Some(clipboard_subproc), 0, Box::into_raw(ctx) as usize) };

        if winapi_result == FALSE {
            return Err(WinCliprdrError::WindowSubclass);
        }

        Ok(Self {
            window,
            backend_tx,
            _thread_marker: Default::default(),
        })
    }

    /// Returns clipboard backend factory suitable for making backend instances for `CLIPRDR` SVC.
    pub fn backend_factory(&self) -> Box<dyn CliprdrBackendFactory + Send> {
        Box::new(WinCliprdrBackendFactory {
            tx: self.backend_tx.clone(),
            window: self.window,
        })
    }
}

impl Drop for WinClipboard {
    fn drop(&mut self) {
        // Remove clipboard processing from WinAPI event loop

        // SAFETY: Format listener was registered in the `new` method previously.
        unsafe { RemoveClipboardFormatListener(self.window) };

        // SAFETY: Subclass was registered in the `new` method previously.
        unsafe { RemoveWindowSubclass(self.window, Some(clipboard_subproc), 0) };
    }
}

/// Windows-specific clipboard backend factory
struct WinCliprdrBackendFactory {
    tx: mpsc_sync::SyncSender<BackendEvent>,
    window: HWND,
}

impl CliprdrBackendFactory for WinCliprdrBackendFactory {
    fn build_cliprdr_backend(&self) -> Box<dyn CliprdrBackend> {
        Box::new(WinCliprdrBackend::new(self.window, self.tx.clone()))
    }
}
