mod clipboard_data_ref;
mod clipboard_impl;
mod cliprdr_backend;
mod os_clipboard;
mod remote_format_registry;
mod utils;

use std::sync::mpsc as mpsc_sync;

use ironrdp_cliprdr::backend::{ClipboardMessageProxy, CliprdrBackend, CliprdrBackendFactory};
use ironrdp_cliprdr::pdu::{
    ClipboardFormat, ClipboardFormatId, ClipboardGeneralCapabilityFlags, FormatDataRequest, FormatDataResponse,
};
use thiserror::Error;
use tracing::error;
use windows::core::{s, Error};
use windows::Win32::Foundation::*;
use windows::Win32::System::DataExchange::{AddClipboardFormatListener, RemoveClipboardFormatListener};
use windows::Win32::System::LibraryLoader::GetModuleHandleA;
use windows::Win32::UI::Shell::{RemoveWindowSubclass, SetWindowSubclass};
use windows::Win32::UI::WindowsAndMessaging::{
    CreateWindowExA, DefWindowProcA, RegisterClassA, CW_USEDEFAULT, WINDOW_EX_STYLE, WM_USER, WNDCLASSA, WS_POPUP,
};

use self::clipboard_impl::{clipboard_subproc, WinClipboardImpl};
use self::cliprdr_backend::WinCliprdrBackend;

pub use windows::Win32::Foundation::HWND;

const BACKEND_CHANNEL_SIZE: usize = 8;
const WM_CLIPRDR_BACKEND_EVENT: u32 = WM_USER;

pub type WinCliprdrResult<T> = Result<T, WinCliprdrError>;

#[derive(Debug, Error)]
pub enum WinCliprdrError {
    #[error("failed to register clipboard format listener")]
    AddClipboardFormatListener,

    #[error("failed to enumerate formats available in the current clipboard")]
    FormatsEnumeration,

    #[error("clipboard is busy")]
    ClipboardAccessDenied,

    #[error("failed to open the clipboard")]
    ClipboardOpen,

    #[error("failed to empty the clipboard")]
    ClipboardEmpty,

    #[error("failed to convert UTF-16 string to UTF-8")]
    Uft16Conversion,

    #[error("failed to get current clipboard data")]
    ClipboardData,

    #[error("failed to set clipboard data")]
    SetClipboardData,

    #[error("failed to subclass window")]
    WindowSubclass,

    #[error("failed to allocate global memory")]
    Alloc,

    #[error("failed to receive data from remote clipboard")]
    DataReceiveTimeout,

    #[error("failed to render clipboard format")]
    RenderFormat,

    #[error("WinAPI error")]
    WinAPI(#[from] Error),
}

/// Sent from the clipboard backend shim to the actual WinAPI subproc event loop
#[derive(Debug)]
pub(crate) enum BackendEvent {
    // Events generated by OS event loop
    ClipboardUpdated,
    RenderFormat(ClipboardFormatId),
    RenderAllFormats,

    // PDU processing events
    DowngradedCapabilities(ClipboardGeneralCapabilityFlags),
    RemoteFormatList(Vec<ClipboardFormat>),
    FormatDataRequest(FormatDataRequest),
    FormatDataResponse(FormatDataResponse<'static>),
    RemoteRequestsFormatList,
}

/// Windows RDP client clipboard implementation.
///
/// IronRDP client implementation should provide raw window handle and message proxy to send
/// messages from the backend to `CLIPRDR` SVC.
///
/// [`WinClipboard`] instance holds ownership of the actual clipboard backend processing logic
/// and should be kept alive during the whole lifetime of the application.
///
/// This type is not thread safe, it should be used only in the main thread with a windows event
/// loop. (GUI thread). However, backend factory returned by [`WinClipboard::backend_factory`]
/// can be safely used in other threads.
pub struct WinClipboard {
    window: HWND,
    backend_tx: mpsc_sync::SyncSender<BackendEvent>,

    /// From MS docs:
    /// ```text
    /// You cannot use the subclassing helper functions to subclass a window across threads
    /// ```
    ///
    /// Therefore this type should be non-Send and non-Sync to prevent incorrect use.
    _thread_marker: std::marker::PhantomData<*const ()>,
}

impl WinClipboard {
    /// Creates new clipboard instance.
    ///
    /// Under the hood, a hidden window is created for capturing the clipboard events.
    pub fn new(message_proxy: impl ClipboardMessageProxy + 'static) -> WinCliprdrResult<Self> {
        extern "system" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
            // SAFETY: default handler
            unsafe { DefWindowProcA(window, message, wparam, lparam) }
        }

        // SAFETY: low-level WinAPI call
        let instance = unsafe { GetModuleHandleA(None)? };
        let window_class = s!("IronRDPClipboardMonitor");
        let wc = WNDCLASSA {
            hInstance: instance.into(),
            lpszClassName: window_class,
            lpfnWndProc: Some(wndproc),
            ..Default::default()
        };

        // SAFETY: low-level WinAPI call
        let atom = unsafe { RegisterClassA(&wc) };
        if atom == 0 {
            return Err(Error::from_win32())?;
        }

        // SAFETY: low-level WinAPI call
        let window = unsafe {
            CreateWindowExA(
                WINDOW_EX_STYLE::default(),
                window_class,
                None,
                WS_POPUP,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                None,
                None,
                instance,
                None,
            )?
        };

        if window.is_invalid() {
            return Err(Error::from_win32())?;
        }
        // Init clipboard processing for WinAPI event loop
        //
        // SAFETY: `window` is a valid window handle
        unsafe { AddClipboardFormatListener(window)? };

        let (backend_tx, backend_rx) = mpsc_sync::sync_channel(BACKEND_CHANNEL_SIZE);

        let ctx = Box::new(WinClipboardImpl::new(window, message_proxy, backend_rx));

        // We need to receive winapi messages in the main thread, so we need to add a subclass to
        // the window.
        //
        // SAFETY: `window` is a valid window handle, `clipboard_subproc` is in the static memory,
        // `ctx` is valid and its ownership is transferred to the subclass via `into_raw`.
        let winapi_result =
            unsafe { SetWindowSubclass(window, Some(clipboard_subproc), 0, Box::into_raw(ctx) as usize) };

        if winapi_result == FALSE {
            return Err(WinCliprdrError::WindowSubclass);
        }

        Ok(Self {
            window,
            backend_tx,
            _thread_marker: Default::default(),
        })
    }

    /// Returns clipboard backend factory suitable for making backend instances for `CLIPRDR` SVC.
    pub fn backend_factory(&self) -> Box<dyn CliprdrBackendFactory + Send> {
        Box::new(WinCliprdrBackendFactory {
            tx: self.backend_tx.clone(),
            window: self.window,
        })
    }
}

impl Drop for WinClipboard {
    fn drop(&mut self) {
        // Remove clipboard processing from WinAPI event loop

        // SAFETY: Format listener was registered in the `new` method previously.
        if let Err(err) = unsafe { RemoveClipboardFormatListener(self.window) } {
            error!("Failed to remove clipboard listener: {}", err)
        }

        // SAFETY: Subclass was registered in the `new` method previously.
        if !unsafe { RemoveWindowSubclass(self.window, Some(clipboard_subproc), 0) }.as_bool() {
            error!("Failed to remove window subclass")
        }
    }
}

/// Windows-specific clipboard backend factory
struct WinCliprdrBackendFactory {
    tx: mpsc_sync::SyncSender<BackendEvent>,
    window: HWND,
}

// SAFETY: window handle is thread safe for PostMessageW usage
unsafe impl Send for WinCliprdrBackendFactory {}

impl CliprdrBackendFactory for WinCliprdrBackendFactory {
    fn build_cliprdr_backend(&self) -> Box<dyn CliprdrBackend> {
        Box::new(WinCliprdrBackend::new(self.window, self.tx.clone()))
    }
}
