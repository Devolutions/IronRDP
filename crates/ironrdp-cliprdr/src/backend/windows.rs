mod clipboard_data;
mod clipboard_data_ref;
mod clipboard_impl;
mod cliprdr_backend;
mod os_clipboard;
mod remote_format_registry;

use self::clipboard_impl::{clipboard_subproc, WinClipboardImpl};
use self::cliprdr_backend::WinCliprdrBackend;

use crate::backend::{ClipboardMessageProxy, CliprdrBackendFactory};
use crate::pdu::{
    ClipboardFormat, ClipboardFormatId, ClipboardGeneralCapabilityFlags, FormatDataRequest, FormatDataResponse,
};
use crate::CliprdrBackend;

use thiserror::Error;
use tracing::error;
use winapi::shared::basetsd::DWORD_PTR;
use winapi::shared::windef::HWND;
use winapi::um::commctrl::{RemoveWindowSubclass, SetWindowSubclass};
use winapi::um::winuser::{AddClipboardFormatListener, RemoveClipboardFormatListener, WM_USER};

use std::sync::{mpsc as mpsc_sync, Arc};

const BACKEND_CHANNEL_SIZE: usize = 8;
const WM_USER_CLIPBOARD: u32 = WM_USER;

pub type WinCliprdrResult<T> = Result<T, WinCliprdrError>;

#[derive(Debug, Error)]
pub enum WinCliprdrError {
    #[error("Failed to register clipboard format listener")]
    AddClipboardFormatListener,

    #[error("Failed to enumerate formats available in the current clipboard")]
    FormatsEnumeration,

    #[error("Clipboard is busy")]
    ClipboardAccessDenied,

    #[error("Failed to open the clipboard")]
    ClipboardOpen,

    #[error("Failed to empty the clipboard")]
    ClipboardEmpty,

    #[error("Failed to convert UTF-16 string to UTF-8")]
    Uft16Conversion,

    #[error("Failed to get current clipboard data")]
    ClipboardData,

    #[error("Failed to set clipboard data")]
    SetClipboardData,

    #[error("Failed to subclass window")]
    WindowSubclass,

    #[error("Failed to allocate global memory")]
    Alloc,

    #[error("Failed to receive data from remote clipboard")]
    DataReceiveTimeout,

    #[error("Failed to render clipboard format")]
    RenderFormat,
}

/// Sent from the clipboard backend shim to the actual WinAPI subproc event loop
#[derive(Debug)]
pub(crate) enum BackendEvent {
    // Events generated by OS event loop
    ClipboardUpdated,
    RenderFormat(ClipboardFormatId),
    RenderAllFormats,

    // PDU processing events
    DowngradedCapabilities(ClipboardGeneralCapabilityFlags),
    RemoteFormatList(Vec<ClipboardFormat>),
    FormatDataRequest(FormatDataRequest),
    FormatDataResponse(FormatDataResponse<'static>),
    RemoteRequestsFormatList,
}

/// Windows RDP client clipboard implementation.
///
/// IronRDP client implementation should provide raw window handle and message proxy to send
/// messages from the backend to `CLIPRDR` SVC.
pub struct WinClipboard {
    /// HWND is declated as non-Send type, but it is actually safe to send and use it between threads,
    /// as long as GUI updates are not performed from the background thread. We use workaround here
    /// to keep the handle as usize instead of pointer
    window: usize,
    backend_tx: mpsc_sync::SyncSender<BackendEvent>,
}

impl WinClipboard {
    /// Creates new clipboard instance.
    #[allow(clippy::not_unsafe_ptr_arg_deref)] // False positive, HWND is a handle, not a pointer
    pub fn new(window: HWND, message_proxy: impl ClipboardMessageProxy + 'static) -> WinCliprdrResult<Arc<Self>> {
        // Init clipboard processing for WinAPI event loop
        if unsafe { AddClipboardFormatListener(window) } == 0 {
            return Err(WinCliprdrError::AddClipboardFormatListener);
        };

        let (backend_tx, backend_rx) = mpsc_sync::sync_channel(BACKEND_CHANNEL_SIZE);

        let ctx = Box::new(WinClipboardImpl {
            message_proxy: message_proxy.clone_box(),
            backend_rx,
            window,
            attempt: 0,
            retry_message: None,
            // We assume that we start with current window active
            window_is_active: true,
            remote_format_registry: Default::default(),
            available_formats_on_remote: Vec::new(),
        });

        // We need to receive winapi messages in the main thread, so we need to add a subclass to
        // the window.
        let winapi_result =
            unsafe { SetWindowSubclass(window, Some(clipboard_subproc), 0, Box::into_raw(ctx) as DWORD_PTR) };

        if winapi_result == 0 {
            return Err(WinCliprdrError::WindowSubclass);
        }

        Ok(Arc::new(Self {
            window: window as _,
            backend_tx,
        }))
    }

    /// Returns clipboard backend factory suitable for making backend instances for `CLIPRDR` SVC.
    pub fn backend_factory(self: &Arc<Self>) -> WinCliprdrBackendFactory {
        WinCliprdrBackendFactory {
            tx: self.backend_tx.clone(),
            win_clipboard: self.clone(),
        }
    }
}

impl Drop for WinClipboard {
    fn drop(&mut self) {
        // Remove clipboard processing from WinAPI event loop
        unsafe {
            RemoveClipboardFormatListener(self.window as _);
            RemoveWindowSubclass(self.window as _, Some(clipboard_subproc), 0);
        }
    }
}

/// Windows-specific clipboard backend factory
pub struct WinCliprdrBackendFactory {
    tx: mpsc_sync::SyncSender<BackendEvent>,
    win_clipboard: Arc<WinClipboard>,
}

impl CliprdrBackendFactory for WinCliprdrBackendFactory {
    fn build_cliprdr_backend(&self) -> Box<dyn CliprdrBackend> {
        Box::new(WinCliprdrBackend::new(self.win_clipboard.window as _, self.tx.clone()))
    }
}
