






    /*let mut cl = NtlmV2ClientBuilder::new()
        .build(Some("D"), "steffen.butzer", "x"); // TODO!!! creds
    
    let mut prev: Option<Vec<u8>> = None;
    for i in 0..5 {
        println!("NTLM ROUND {i}");
        let nb = cl.next_bytes(prev.as_ref().map(Vec::as_slice)).unwrap();
        if nb.is_none() {
            println!("NTLM Rounds done");
            break;
        }

        let req = ExtendedAuthPkt {
            error_code: 0,
            blob: nb.unwrap(),
        };
        let mut buf = [0u8; 65535];
        let pos = {
            let mut cur = WriteCursor::new(&mut buf);
            req.encode(&mut cur).unwrap();
            cur.pos() as usize
        };
        println!("EXT_AUTH_REQ: {:?}", &buf[..16]);
        ws_stream.send(Message::Binary(Bytes::copy_from_slice(&buf[..pos]))).await?;

        if let Some(next) = ws_stream.next().await {
            let msg: Bytes = next.unwrap().into_data();
            println!("{:?}", &msg[..16]);
            let mut cur = ReadCursor::new(&msg);
            let hdr: PktHdr = PktHdr::decode(&mut cur).unwrap();
            assert!(cur.len() >= hdr.length as usize - hdr.size());
            
                assert_eq!(hdr.ty, PktTy::TunnelResp);
                let resp = TunnelRespPkt::decode(&mut cur).unwrap();

                println!("DBG SHOULDNT BE HERE TUNNEL RESP: {:?}", resp);
            
            assert_eq!(hdr.ty, PktTy::ExtendedAuth);
            let resp = ExtendedAuthPkt::decode(&mut cur).unwrap();

            println!("EXT_AUTH_RESP: {:?}", resp.blob.len());
            assert_eq!(resp.error_code, 0);
            prev = Some(resp.blob);
        }
    }*/
